/* 
 * OpenAPI spec version: 2.4.9
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package swagger

import (
	"strings"
	"fmt"
	"errors"
	"net/url"
	"encoding/json"
)

type VdomainsApi struct {
	Configuration Configuration
}

func NewVdomainsApi() *VdomainsApi {
	configuration := NewConfiguration()
	return &VdomainsApi{
		Configuration: *configuration,
	}
}

func NewVdomainsApiWithBasePath(basePath string) *VdomainsApi {
	configuration := NewConfiguration()
	configuration.BasePath = basePath

	return &VdomainsApi{
		Configuration: *configuration,
	}
}

/**
 * Determine whether or not the specified domain is available for purchase
 *
 * @param domain Domain name whose availability is to be checked
 * @param checkType Optimize for time (&#39;FAST&#39;) or accuracy (&#39;FULL&#39;)
 * @param forTransfer Whether or not to include domains available for transfer. If set to True, checkType is ignored
 * @return *DomainAvailableResponse
 */
func (a VdomainsApi) Available(domain string, checkType string, forTransfer bool) (*DomainAvailableResponse, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/available"

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return new(DomainAvailableResponse), nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->Available")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("domain", a.Configuration.APIClient.ParameterToString(domain, ""))
			queryParams.Add("checkType", a.Configuration.APIClient.ParameterToString(checkType, ""))
			queryParams.Add("forTransfer", a.Configuration.APIClient.ParameterToString(forTransfer, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(DomainAvailableResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Determine whether or not the specified domains are available for purchase
 *
 * @param domains Domain names for which to check availability
 * @param checkType Optimize for time (&#39;FAST&#39;) or accuracy (&#39;FULL&#39;)
 * @return *DomainAvailableBulk
 */
func (a VdomainsApi) AvailableBulk(domains []string, checkType string) (*DomainAvailableBulk, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/available"

	// verify the required parameter 'domains' is set
	if &domains == nil {
		return *new(DomainAvailableBulk), nil, errors.New("Missing required parameter 'domains' when calling VdomainsApi->AvailableBulk")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("checkType", a.Configuration.APIClient.ParameterToString(checkType, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &domains

	var successPayload = new(DomainAvailableBulk)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Cancel a purchased domain
 *
 * @param domain Domain to cancel
 * @return void
 */
func (a VdomainsApi) Cancel(domain string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->Cancel")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Submit a privacy cancellation request for the given domain
 *
 * @param domain Domain whose privacy is to be cancelled
 * @param xShopperId Shopper ID of the owner of the domain
 * @return void
 */
func (a VdomainsApi) CancelPrivacy(domain string, xShopperId string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}/privacy"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->CancelPrivacy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Retrieve details for the specified Domain
 *
 * @param domain Domain name whose details are to be retrieved
 * @param xShopperId Shopper ID expected to own the specified domain
 * @return *DomainDetail
 */
func (a VdomainsApi) Get(domain string, xShopperId string) (*DomainDetail, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return new(DomainDetail), nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->Get")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	var successPayload = new(DomainDetail)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Retrieve the legal agreement(s) required to purchase the specified TLD and add-ons
 *
 * @param tlds list of TLDs whose legal agreements are to be retrieved
 * @param privacy Whether or not privacy has been requested
 * @param xMarketId Unique identifier of the Market used to retrieve/translate Legal Agreements
 * @param forTransfer Whether or not domain tranfer has been requested
 * @return []LegalAgreement
 */
func (a VdomainsApi) GetAgreement(tlds []string, privacy bool, xMarketId string, forTransfer bool) ([]LegalAgreement, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/agreements"

	// verify the required parameter 'tlds' is set
	if &tlds == nil {
		return *new([]LegalAgreement), nil, errors.New("Missing required parameter 'tlds' when calling VdomainsApi->GetAgreement")
	}
	// verify the required parameter 'privacy' is set
	if &privacy == nil {
		return new([]LegalAgreement), nil, errors.New("Missing required parameter 'privacy' when calling VdomainsApi->GetAgreement")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range tlds {
			queryParams.Add("tlds", value)
		}
	} else {
		queryParams.Add("tlds", a.Configuration.APIClient.ParameterToString(tlds, collectionFormat))
	}
			queryParams.Add("privacy", a.Configuration.APIClient.ParameterToString(privacy, ""))
			queryParams.Add("forTransfer", a.Configuration.APIClient.ParameterToString(forTransfer, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Market-Id"
	headerParams["X-Market-Id"] = xMarketId

	var successPayload = new([]LegalAgreement)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Retrieve a list of Domains for the specified Shopper
 *
 * @param xShopperId Shopper ID whose domains are to be retrieved
 * @param statuses Only include results with &#x60;status&#x60; value in the specified set
 * @param statusGroups Only include results with &#x60;status&#x60; value in any of the specified groups
 * @param limit Maximum number of domains to return
 * @param marker Marker Domain to use as the offset in results
 * @param includes Optional details to be included in the response
 * @param modifiedDate Only include results that have been modified since the specified date
 * @return []DomainSummary
 */
func (a VdomainsApi) List(xShopperId string, statuses []string, statusGroups []string, limit int32, marker string, includes []string, modifiedDate string) ([]DomainSummary, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
	var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range statuses {
			queryParams.Add("statuses", value)
		}
	} else {
		queryParams.Add("statuses", a.Configuration.APIClient.ParameterToString(statuses, collectionFormat))
	}
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range statusGroups {
			queryParams.Add("statusGroups", value)
		}
	} else {
		queryParams.Add("statusGroups", a.Configuration.APIClient.ParameterToString(statusGroups, collectionFormat))
	}
			queryParams.Add("limit", a.Configuration.APIClient.ParameterToString(limit, ""))
			queryParams.Add("marker", a.Configuration.APIClient.ParameterToString(marker, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range includes {
			queryParams.Add("includes", value)
		}
	} else {
		queryParams.Add("includes", a.Configuration.APIClient.ParameterToString(includes, collectionFormat))
	}
			queryParams.Add("modifiedDate", a.Configuration.APIClient.ParameterToString(modifiedDate, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	var successPayload = new([]DomainSummary)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Purchase and register the specified Domain
 *
 * @param body An instance document expected to match the JSON schema returned by &#x60;./schema/{tld}&#x60;
 * @param xShopperId The Shopper for whom the domain should be purchased
 * @return *DomainPurchaseResponse
 */
func (a VdomainsApi) Purchase(body DomainPurchase, xShopperId string) (*DomainPurchaseResponse, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/purchase"

	// verify the required parameter 'body' is set
	if &body == nil {
		return new(DomainPurchaseResponse), nil, errors.New("Missing required parameter 'body' when calling VdomainsApi->Purchase")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	// body params
	postBody = &body

	var successPayload = new(DomainPurchaseResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Purchase privacy for a specified domain
 *
 * @param domain Domain for which to purchase privacy
 * @param body Options for purchasing privacy
 * @param xShopperId Shopper ID of the owner of the domain
 * @return *DomainPurchaseResponse
 */
func (a VdomainsApi) PurchasePrivacy(domain string, body PrivacyPurchase, xShopperId string) (*DomainPurchaseResponse, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}/privacy/purchase"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return new(DomainPurchaseResponse), nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->PurchasePrivacy")
	}
	// verify the required parameter 'body' is set
	if &body == nil {
		return new(DomainPurchaseResponse), nil, errors.New("Missing required parameter 'body' when calling VdomainsApi->PurchasePrivacy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	// body params
	postBody = &body

	var successPayload = new(DomainPurchaseResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Add the specified DNS Records to the specified Domain
 *
 * @param domain Domain whose DNS Records are to be augmented
 * @param records DNS Records to add to whatever currently exists
 * @param xShopperId Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
 * @return void
 */
func (a VdomainsApi) RecordAdd(domain string, records DnsRecord, xShopperId string) (*APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}/records"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->RecordAdd")
	}
	// verify the required parameter 'records' is set
	if &records == nil {
		return nil, errors.New("Missing required parameter 'records' when calling VdomainsApi->RecordAdd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	// body params
	postBody = &records


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Retrieve DNS Records for the specified Domain, optionally with the specified Type and/or Name
 *
 * @param domain Domain whose DNS Records are to be retrieved
 * @param type_ DNS Record Type for which DNS Records are to be retrieved
 * @param name DNS Record Name for which DNS Records are to be retrieved
 * @param xShopperId Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
 * @param offset Number of results to skip for pagination
 * @param limit Maximum number of items to return
 * @return []DnsRecord
 */
func (a VdomainsApi) RecordGet(domain string, type_ string, name string, xShopperId string, offset int32, limit int32) ([]DnsRecord, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}/records/{type?}/{name?}"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)
	path = strings.Replace(path, "{"+"type"+"}", fmt.Sprintf("%v", type_), -1)
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return new([]DnsRecord), nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->RecordGet")
	}
	// verify the required parameter 'type_' is set
	if &type_ == nil {
		return new([]DnsRecord), nil, errors.New("Missing required parameter 'type_' when calling VdomainsApi->RecordGet")
	}
	// verify the required parameter 'name' is set
	if &name == nil {
		return new([]DnsRecord), nil, errors.New("Missing required parameter 'name' when calling VdomainsApi->RecordGet")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("offset", a.Configuration.APIClient.ParameterToString(offset, ""))
			queryParams.Add("limit", a.Configuration.APIClient.ParameterToString(limit, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	var successPayload = new([]DnsRecord)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Replace all DNS Records for the specified Domain
 *
 * @param domain Domain whose DNS Records are to be replaced
 * @param records DNS Records to replace whatever currently exists
 * @param xShopperId Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
 * @return void
 */
func (a VdomainsApi) RecordReplace(domain string, records []DnsRecord, xShopperId string) (*APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}/records"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->RecordReplace")
	}
	// verify the required parameter 'records' is set
	if &records == nil {
		return nil, errors.New("Missing required parameter 'records' when calling VdomainsApi->RecordReplace")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	// body params
	postBody = &records


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Replace all DNS Records for the specified Domain with the specified Type
 *
 * @param domain Domain whose DNS Records are to be replaced
 * @param type_ DNS Record Type for which DNS Records are to be replaced
 * @param records DNS Records to replace whatever currently exists
 * @param xShopperId Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
 * @return void
 */
func (a VdomainsApi) RecordReplaceType(domain string, type_ string, records []DnsRecordCreateType, xShopperId string) (*APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}/records/{type}"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)
	path = strings.Replace(path, "{"+"type"+"}", fmt.Sprintf("%v", type_), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->RecordReplaceType")
	}
	// verify the required parameter 'type_' is set
	if &type_ == nil {
		return nil, errors.New("Missing required parameter 'type_' when calling VdomainsApi->RecordReplaceType")
	}
	// verify the required parameter 'records' is set
	if &records == nil {
		return nil, errors.New("Missing required parameter 'records' when calling VdomainsApi->RecordReplaceType")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	// body params
	postBody = &records


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Replace all DNS Records for the specified Domain with the specified Type and Name
 *
 * @param domain Domain whose DNS Records are to be replaced
 * @param type_ DNS Record Type for which DNS Records are to be replaced
 * @param name DNS Record Name for which DNS Records are to be replaced
 * @param records DNS Records to replace whatever currently exists
 * @param xShopperId Shopper ID which owns the domain. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
 * @return void
 */
func (a VdomainsApi) RecordReplaceTypeName(domain string, type_ string, name string, records []DnsRecordCreateTypeName, xShopperId string) (*APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}/records/{type}/{name}"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)
	path = strings.Replace(path, "{"+"type"+"}", fmt.Sprintf("%v", type_), -1)
	path = strings.Replace(path, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->RecordReplaceTypeName")
	}
	// verify the required parameter 'type_' is set
	if &type_ == nil {
		return nil, errors.New("Missing required parameter 'type_' when calling VdomainsApi->RecordReplaceTypeName")
	}
	// verify the required parameter 'name' is set
	if &name == nil {
		return nil, errors.New("Missing required parameter 'name' when calling VdomainsApi->RecordReplaceTypeName")
	}
	// verify the required parameter 'records' is set
	if &records == nil {
		return nil, errors.New("Missing required parameter 'records' when calling VdomainsApi->RecordReplaceTypeName")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	// body params
	postBody = &records


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Renew the specified Domain
 *
 * @param domain Domain to renew
 * @param xShopperId Shopper for whom Domain is to be renewed. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
 * @param body Options for renewing existing Domain
 * @return *DomainPurchaseResponse
 */
func (a VdomainsApi) Renew(domain string, xShopperId string, body DomainRenew) (*DomainPurchaseResponse, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}/renew"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return new(DomainPurchaseResponse), nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->Renew")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	// body params
	postBody = &body

	var successPayload = new(DomainPurchaseResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Retrieve the schema to be submitted when registering a Domain for the specified TLD
 * 
 *
 * @param tld The Top-Level Domain whose schema should be retrieved
 * @return *JsonSchema
 */
func (a VdomainsApi) Schema(tld string) (*JsonSchema, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/purchase/schema/{tld}"
	path = strings.Replace(path, "{"+"tld"+"}", fmt.Sprintf("%v", tld), -1)

	// verify the required parameter 'tld' is set
	if &tld == nil {
		return new(JsonSchema), nil, errors.New("Missing required parameter 'tld' when calling VdomainsApi->Schema")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(JsonSchema)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Suggest alternate Domain names based on a seed Domain, a set of keywords, or the shopper&#39;s purchase history
 *
 * @param xShopperId Shopper ID for which the suggestions are being generated
 * @param query Domain name or set of keywords for which alternative domain names will be suggested
 * @param country Two-letter ISO country code to be used as a hint for target region&lt;br/&gt;&lt;br/&gt; NOTE: These are sample values, there are many &lt;a href&#x3D;\&quot;http://www.iso.org/iso/country_codes.htm\&quot;&gt;more&lt;/a&gt;
 * @param city Name of city to be used as a hint for target region
 * @param sources Sources to be queried&lt;br/&gt;&lt;br/&gt;&lt;ul&gt; &lt;li&gt;&lt;strong&gt;CC_TLD&lt;/strong&gt; - Varies the TLD using Country Codes&lt;/li&gt; &lt;li&gt;&lt;strong&gt;EXTENSION&lt;/strong&gt; - Varies the TLD&lt;/li&gt; &lt;li&gt;&lt;strong&gt;KEYWORD_SPIN&lt;/strong&gt; - Identifies keywords and then rotates each one&lt;/li&gt; &lt;li&gt;&lt;strong&gt;PREMIUM&lt;/strong&gt; - Includes variations with premium prices&lt;/li&gt;&lt;/ul&gt;
 * @param tlds Top-level domains to be included in suggestions&lt;br/&gt;&lt;br/&gt; NOTE: These are sample values, there are many &lt;a href&#x3D;\&quot;http://www.godaddy.com/tlds/gtld.aspx#domain_search_form\&quot;&gt;more&lt;/a&gt;
 * @param lengthMax Maximum length of second-level domain
 * @param lengthMin Minimum length of second-level domain
 * @param limit Maximum number of suggestions to return
 * @param waitMs Maximum amount of time, in milliseconds, to wait for responses If elapses, return the results compiled up to that point
 * @return []DomainSuggestion
 */
func (a VdomainsApi) Suggest(xShopperId string, query string, country string, city string, sources []string, tlds []string, lengthMax int32, lengthMin int32, limit int32, waitMs int32) ([]DomainSuggestion, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/suggest"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("query", a.Configuration.APIClient.ParameterToString(query, ""))
			queryParams.Add("country", a.Configuration.APIClient.ParameterToString(country, ""))
			queryParams.Add("city", a.Configuration.APIClient.ParameterToString(city, ""))
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range sources {
			queryParams.Add("sources", value)
		}
	} else {
		queryParams.Add("sources", a.Configuration.APIClient.ParameterToString(sources, collectionFormat))
	}
		var collectionFormat = "csv"
	if collectionFormat == "multi" {
		for _, value := range tlds {
			queryParams.Add("tlds", value)
		}
	} else {
		queryParams.Add("tlds", a.Configuration.APIClient.ParameterToString(tlds, collectionFormat))
	}
			queryParams.Add("lengthMax", a.Configuration.APIClient.ParameterToString(lengthMax, ""))
			queryParams.Add("lengthMin", a.Configuration.APIClient.ParameterToString(lengthMin, ""))
			queryParams.Add("limit", a.Configuration.APIClient.ParameterToString(limit, ""))
			queryParams.Add("waitMs", a.Configuration.APIClient.ParameterToString(waitMs, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	var successPayload = new([]DomainSuggestion)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Retrieves a list of TLDs supported and enabled for sale
 *
 * @return []TldSummary
 */
func (a VdomainsApi) Tlds() ([]TldSummary, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/tlds"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new([]TldSummary)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Purchase and start or restart transfer process
 *
 * @param domain Domain to transfer in
 * @param body Details for domain transfer purchase
 * @param xShopperId The Shopper to whom the domain should be transfered
 * @return *DomainPurchaseResponse
 */
func (a VdomainsApi) TransferIn(domain string, body DomainTransferIn, xShopperId string) (*DomainPurchaseResponse, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}/transfer"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return new(DomainPurchaseResponse), nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->TransferIn")
	}
	// verify the required parameter 'body' is set
	if &body == nil {
		return new(DomainPurchaseResponse), nil, errors.New("Missing required parameter 'body' when calling VdomainsApi->TransferIn")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	// body params
	postBody = &body

	var successPayload = new(DomainPurchaseResponse)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Update details for the specified Domain
 *
 * @param domain Domain whose details are to be updated
 * @param body Changes to apply to existing Domain
 * @param xShopperId Shopper for whom Domain is to be updated. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
 * @return void
 */
func (a VdomainsApi) Update(domain string, body DomainUpdate, xShopperId string) (*APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->Update")
	}
	// verify the required parameter 'body' is set
	if &body == nil {
		return nil, errors.New("Missing required parameter 'body' when calling VdomainsApi->Update")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	// body params
	postBody = &body


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Update domain
 *
 * @param domain Domain whose Contacts are to be updated.
 * @param contacts Changes to apply to existing Contacts
 * @param xShopperId Shopper for whom domain contacts are to be updated. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
 * @return void
 */
func (a VdomainsApi) UpdateContacts(domain string, contacts DomainContacts, xShopperId string) (*APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}/contacts"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->UpdateContacts")
	}
	// verify the required parameter 'contacts' is set
	if &contacts == nil {
		return nil, errors.New("Missing required parameter 'contacts' when calling VdomainsApi->UpdateContacts")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId

	// body params
	postBody = &contacts


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Validate the request body using the Domain Purchase Schema for the specified TLD
 * 
 *
 * @param body An instance document expected to match the JSON schema returned by &#x60;./schema/{tld}&#x60;
 * @return void
 */
func (a VdomainsApi) Validate(body DomainPurchase) (*APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/purchase/validate"

	// verify the required parameter 'body' is set
	if &body == nil {
		return nil, errors.New("Missing required parameter 'body' when calling VdomainsApi->Validate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &body


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * Re-send Contact E-mail Verification for specified Domain
 *
 * @param domain Domain whose Contact E-mail should be verified.
 * @param xShopperId Shopper for whom domain contact e-mail should be verified. NOTE: This is only required if you are a Reseller managing a domain purchased outside the scope of your reseller account. For instance, if you&#39;re a Reseller, but purchased a Domain via http://www.godaddy.com
 * @return void
 */
func (a VdomainsApi) VerifyEmail(domain string, xShopperId string) (*APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.Configuration.BasePath + "/v1/domains/{domain}/verifyRegistrantEmail"
	path = strings.Replace(path, "{"+"domain"+"}", fmt.Sprintf("%v", domain), -1)

	// verify the required parameter 'domain' is set
	if &domain == nil {
		return nil, errors.New("Missing required parameter 'domain' when calling VdomainsApi->VerifyEmail")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json", "application/xml", "text/xml",  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
"application/javascript",
"application/xml",
"text/javascript",
"text/xml",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	// header params "X-Shopper-Id"
	headerParams["X-Shopper-Id"] = xShopperId


	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

